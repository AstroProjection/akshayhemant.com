<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Portfolio with Solar System Visualization</title>
  <style>
    /* Base styles */
    body {
      margin: 0;
      padding: 0;
      background: #000;
      color: white;
      font-family: 'SF Pro Display', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
      overflow-x: hidden;
    }
    
    /* Canvas for solar system */
    canvas {
      display: block;
      position: fixed;
      top: 0;
      left: 0;
      z-index: -1; /* Place behind content */
    }
    
    /* Scroll blur overlay */
    .scroll-blur {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.3);
      backdrop-filter: blur(5px);
      -webkit-backdrop-filter: blur(5px);
      z-index: 0;
      opacity: 0;
      transition: opacity 0.5s ease;
      pointer-events: none; /* Allow clicks to pass through */
    }
    
    /* Main content container */
    .content-container {
      position: relative;
      width: 100%;
      z-index: 1;
    }
    
    /* Section styling */
    section {
      min-height: 100vh;
      width: 100%;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 50px 0;
      box-sizing: border-box;
      position: relative;
    }
    
    /* Hero section (first screen) */
    .hero {
      height: 100vh;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      text-align: center;
    }
    
    .hero h1 {
      font-size: 5rem;
      margin: 0;
      opacity: 0;
      transform: translateY(30px);
      transition: opacity 1s ease, transform 1s ease;
    }
    
    .hero p {
      font-size: 1.5rem;
      max-width: 600px;
      margin: 20px 0;
      opacity: 0;
      transform: translateY(30px);
      transition: opacity 1s ease, transform 1s ease;
      transition-delay: 0.2s;
    }
    
    /* Content section styling */
    .content-section {
      display: flex;
      flex-direction: column;
      align-items: center;
      padding: 0 20px;
    }
    
    .section-inner {
      max-width: 1200px;
      width: 100%;
      opacity: 0;
      transform: translateY(50px);
      transition: opacity 1s ease, transform 1s ease;
    }
    
    .section-inner.visible {
      opacity: 1;
      transform: translateY(0);
    }
    
    /* Project card styling */
    .project-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(350px, 1fr));
      gap: 30px;
      margin-top: 40px;
    }
    
    .project-card {
      background: rgba(255, 255, 255, 0.05);
      border-radius: 12px;
      overflow: hidden;
      box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
      transition: transform 0.3s ease, box-shadow 0.3s ease;
    }
    
    .project-card:hover {
      transform: translateY(-10px);
      box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
    }
    
    .project-image {
      width: 100%;
      height: 200px;
      background-color: #333;
      background-size: cover;
      background-position: center;
    }
    
    .project-content {
      padding: 20px;
    }
    
    .project-content h3 {
      margin-top: 0;
      font-size: 1.5rem;
    }
    
    .project-content p {
      margin-bottom: 15px;
      font-size: 1rem;
      line-height: 1.5;
      color: rgba(255, 255, 255, 0.8);
    }
    
    .project-link {
      display: inline-block;
      padding: 8px 16px;
      background: rgba(255, 215, 0, 0.2);
      color: #FFC107;
      text-decoration: none;
      border-radius: 4px;
      font-weight: 500;
      transition: background 0.3s ease;
    }
    
    .project-link:hover {
      background: rgba(255, 215, 0, 0.3);
    }
    
    /* About section styling */
    .about-content {
      display: flex;
      flex-wrap: wrap;
      gap: 40px;
      align-items: center;
    }
    
    .about-image {
      flex: 0 0 300px;
      height: 300px;
      border-radius: 50%;
      background-color: #333;
      background-size: cover;
      background-position: center;
      border: 4px solid rgba(255, 215, 0, 0.3);
    }
    
    .about-text {
      flex: 1;
      min-width: 300px;
    }
    
    .about-text h2 {
      font-size: 2.5rem;
      margin-top: 0;
    }
    
    .about-text p {
      font-size: 1.1rem;
      line-height: 1.6;
      color: rgba(255, 255, 255, 0.9);
    }
    
    /* Contact section styling */
    .contact-form {
      width: 100%;
      max-width: 600px;
    }
    
    .form-group {
      margin-bottom: 20px;
    }
    
    .form-group label {
      display: block;
      margin-bottom: 8px;
      font-size: 1rem;
    }
    
    .form-group input,
    .form-group textarea {
      width: 100%;
      padding: 12px;
      background: rgba(255, 255, 255, 0.05);
      border: 1px solid rgba(255, 255, 255, 0.1);
      border-radius: 4px;
      color: white;
      font-size: 1rem;
      transition: border-color 0.3s ease;
    }
    
    .form-group input:focus,
    .form-group textarea:focus {
      outline: none;
      border-color: rgba(255, 215, 0, 0.5);
    }
    
    .form-group textarea {
      min-height: 150px;
      resize: vertical;
    }
    
    button.submit-btn {
      padding: 12px 24px;
      background: rgba(255, 215, 0, 0.2);
      color: #FFC107;
      border: none;
      border-radius: 4px;
      font-size: 1rem;
      font-weight: 500;
      cursor: pointer;
      transition: background 0.3s ease;
    }
    
    button.submit-btn:hover {
      background: rgba(255, 215, 0, 0.3);
    }
    
    /* Navigation */
    .nav {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      padding: 20px;
      display: flex;
      justify-content: space-between;
      align-items: center;
      z-index: 100;
      transition: background 0.3s ease;
    }
    
    .nav.scrolled {
      background: rgba(0, 0, 0, 0.8);
      backdrop-filter: blur(10px);
    }
    
    .logo {
      font-size: 1.5rem;
      font-weight: bold;
      color: white;
      text-decoration: none;
    }
    
    .nav-links {
      display: flex;
      gap: 20px;
    }
    
    .nav-links a {
      color: white;
      text-decoration: none;
      font-size: 1rem;
      transition: color 0.3s ease;
    }
    
    .nav-links a:hover {
      color: #FFC107;
    }
    
    /* Updated speed display styling */
    .speed-display {
      position: fixed;
      top: 80px; /* Moved down from 20px to 80px to avoid overlap with the name */
      left: 20px;
      background: rgba(0, 0, 0, 0.7);
      color: white;
      padding: 15px 20px;
      border-radius: 8px;
      font-size: 18px;
      z-index: 100;
      box-shadow: 0 0 10px rgba(255, 215, 0, 0.3);
      border: 1px solid rgba(255, 215, 0, 0.2);
      transition: opacity 0.5s ease;
    }
    
    .speed-display .value {
      font-weight: bold;
      color: #FFC107;
      font-size: 24px;
    }
    
    .speed-display .details {
      font-size: 14px;
      opacity: 0.9;
      margin-top: 8px;
      line-height: 1.4;
    }
    
    /* Controls styling */
    .controls {
      position: fixed;
      bottom: 20px;
      right: 20px;
      background: rgba(0, 0, 0, 0.7);
      padding: 15px;
      border-radius: 8px;
      color: white;
      z-index: 100;
      transition: opacity 0.3s ease;
    }
    
    /* Responsive styles */
    @media (max-width: 768px) {
      .hero h1 {
        font-size: 3rem;
      }
      
      .hero p {
        font-size: 1.2rem;
      }
      
      .project-grid {
        grid-template-columns: 1fr;
      }
      
      .about-image {
        flex: 0 0 200px;
        height: 200px;
      }
      
      .nav-links {
        display: none;
      }
    }
  </style>
</head>
<body id="body">
  <!-- Canvas for solar system visualization -->
  <canvas id="rayCanvas"></canvas>
  
  <!-- Scroll blur overlay -->
  <div class="scroll-blur" id="scrollBlur"></div>
  
  <!-- Navigation -->
  <nav class="nav" id="mainNav">
    <a href="#body" class="logo">Akshay Hemant Kumar</a>
    <div class="nav-links">
      <a href="#about">About</a>
      <a href="#projects">Projects</a>
      <a href="#contact">Contact</a>
    </div>
  </nav>
  
  <!-- Speed display -->
  <div class="speed-display" id="speedDisplay">
    <div>Speed: <span class="value" id="speedValue">1000x</span></div>
    <div class="details" id="speedDetails">
      Earth rotation: <span id="hoursValue">0</span> hours/frame<br>
      Earth orbit: <span id="daysValue">0</span> days/frame
    </div>
  </div>
  
  <!-- Main content container -->
  <div class="content-container">
    <!-- Hero section -->
    <section class="hero" id="hero">
      <h1 id="heroTitle">Akshay Hemant Kumar</h1>
      <p id="heroSubtitle">Software Developer & Creative Technologist</p>
    </section>
    
    <!-- About section -->
    <section class="content-section" id="about">
      <div class="section-inner">
        <div class="about-content">
          <div class="about-image" style="background-image: url('../assets/profile-pic.jpg');"></div>
          <div class="about-text">
            <h2>About Me</h2>
            <p>Hello! I'm a passionate developer with a love for creating interactive experiences and beautiful visualizations. With expertise in JavaScript, WebGL, and creative coding, I build digital experiences that combine art and technology.</p>
            <p>My background in [your background] has given me a unique perspective on problem-solving and innovation. I'm constantly exploring new technologies and pushing the boundaries of what's possible on the web.</p>
            <p>When I'm not coding, you can find me [your hobbies/interests].</p>
          </div>
        </div>
      </div>
    </section>
    
    <!-- Projects section -->
    <section class="content-section" id="projects">
      <div class="section-inner">
        <h2>My Projects</h2>
        <p>Here are some of the projects I've worked on recently. Each one represents a unique challenge and learning opportunity.</p>
        
        <div class="project-grid">
          <!-- Project 1 -->
          <div class="project-card">
            <div class="project-image" style="background-image: url('https://via.placeholder.com/350x200');"></div>
            <div class="project-content">
              <h3>Solar System Visualization</h3>
              <p>An interactive visualization of the solar system using WebGL and Three.js, demonstrating orbital mechanics and astronomical phenomena.</p>
              <a href="#" class="project-link">View Project</a>
            </div>
          </div>
          
          <!-- Project 2 -->
          <div class="project-card">
            <div class="project-image" style="background-image: url('https://via.placeholder.com/350x200');"></div>
            <div class="project-content">
              <h3>Data Visualization Dashboard</h3>
              <p>A responsive dashboard for visualizing complex datasets, built with D3.js and React, featuring interactive charts and filters.</p>
              <a href="#" class="project-link">View Project</a>
            </div>
          </div>
          
          <!-- Project 3 -->
          <div class="project-card">
            <div class="project-image" style="background-image: url('https://via.placeholder.com/350x200');"></div>
            <div class="project-content">
              <h3>AI-Powered Web Application</h3>
              <p>A web application that leverages machine learning to provide personalized recommendations and insights to users.</p>
              <a href="#" class="project-link">View Project</a>
            </div>
          </div>
        </div>
      </div>
    </section>
    
    <!-- Contact section -->
    <section class="content-section" id="contact">
      <div class="section-inner">
        <h2>Get In Touch</h2>
        <p>Interested in working together? Feel free to reach out using the form below or connect with me on social media.</p>
        
        <div class="contact-form">
          <div class="form-group">
            <label for="name">Name</label>
            <input type="text" id="name" placeholder="Your name">
          </div>
          
          <div class="form-group">
            <label for="email">Email</label>
            <input type="email" id="email" placeholder="Your email">
          </div>
          
          <div class="form-group">
            <label for="message">Message</label>
            <textarea id="message" placeholder="Your message"></textarea>
          </div>
          
          <button class="submit-btn">Send Message</button>
        </div>
      </div>
    </section>
  </div>
  
  <!-- Controls for solar system -->
  <div class="controls" id="controls">
    <h3>Controls</h3>
    
    <div class="control-group">
      <label for="speedMultiplier">Simulation Speed:</label>
      <input type="range" id="speedMultiplier" min="1" max="10" step="1" value="1">
      <div class="value-display" id="sliderValue">1x</div>
    </div>
    
    <div class="buttons">
      <button id="toggleAnimation">Pause</button>
      <button id="resetView">Reset</button>
    </div>
  </div>

  <script>
    // Canvas setup
    const canvas = document.getElementById('rayCanvas');
    const ctx = canvas.getContext('2d');
    
    // Speed display elements
    const speedDisplay = document.getElementById('speedDisplay');
    const speedValue = document.getElementById('speedValue');
    const speedDetails = document.getElementById('speedDetails');
    const hoursValue = document.getElementById('hoursValue');
    const daysValue = document.getElementById('daysValue');
    const sliderValue = document.getElementById('sliderValue');
    
    // Content elements
    const heroTitle = document.getElementById('heroTitle');
    const heroSubtitle = document.getElementById('heroSubtitle');
    const contentContainer = document.querySelector('.content-container');
    const mainNav = document.getElementById('mainNav');
    const controls = document.getElementById('controls');
    const scrollBlur = document.getElementById('scrollBlur');
    
    // Add transitions for smooth appearance/disappearance
    controls.style.transition = 'opacity 0.5s ease';
    speedDisplay.style.transition = 'opacity 0.5s ease';
    mainNav.style.transition = 'opacity 0.5s ease, background 0.3s ease';
    
    // Initially hide all content but show controls
    heroTitle.style.opacity = '0';
    heroSubtitle.style.opacity = '0';
    mainNav.style.opacity = '0.2';
    controls.style.opacity = '1';
    speedDisplay.style.opacity = '1';
    
    // Set a timer to show initial content after a delay if user hasn't scrolled
    let initialLoadTimeout = setTimeout(() => {
      if (window.scrollY < 10) { // Only reveal if user hasn't scrolled much
        // Keep controls visible, content hidden at top
      } else {
        // If they've scrolled, show content
        revealContent();
      }
    }, 3000); // 3 seconds delay
    
    // Function to reveal content
    function revealContent() {
      mainNav.style.opacity = '1';
      
      // Staggered animation for hero elements
      heroTitle.style.opacity = '1';
      heroTitle.style.transform = 'translateY(0)';
      
      initialLoadTimeout = setTimeout(() => {
        heroSubtitle.style.opacity = '1';
        heroSubtitle.style.transform = 'translateY(0)';
      }, 300);
    }
    
    // Function to hide content
    function hideContent() {
      heroTitle.style.opacity = '0';
      heroTitle.style.transform = 'translateY(30px)';
      heroSubtitle.style.opacity = '0';
      heroSubtitle.style.transform = 'translateY(30px)';
      mainNav.style.opacity = '0.2';
      clearTimeout(initialLoadTimeout);
    }
    
    // Earth image - using a more reliable source and adding error handling
    const earthImage = new Image();
    earthImage.crossOrigin = "Anonymous"; // Handle CORS issues
    earthImage.src = "../assets/earth.jpg";
    
    // Alternative URLs if the first one fails
    const fallbackUrls = [
      'https://upload.wikimedia.org/wikipedia/commons/thumb/c/c3/Earth_from_space_north_pole.jpg/1200px-Earth_from_space_north_pole.jpg',
      'https://eoimages.gsfc.nasa.gov/images/imagerecords/73000/73909/world.topo.bathy.200412.3x5400x2700.jpg'
    ];
    
    let currentUrlIndex = 0;
    let earthImageLoaded = false;
    
    // Success handler
    earthImage.onload = function() {
      console.log("Earth image loaded successfully");
      earthImageLoaded = true;
      if (earth) {
        drawScene(); // Redraw once image is loaded
      }
    };
    
    // Error handler - try fallback URLs
    earthImage.onerror = function() {
      console.log("Error loading Earth image, trying fallback");
      currentUrlIndex++;
      if (currentUrlIndex < fallbackUrls.length) {
        earthImage.src = fallbackUrls[currentUrlIndex];
      } else {
        console.log("All Earth image URLs failed");
      }
    };
    
    // Set canvas to full window size
    function resizeCanvas() {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
    }
    
    // Call resize initially and on window resize
    resizeCanvas();
    window.addEventListener('resize', () => {
      resizeCanvas();
      initScene(); // Reinitialize scene on resize
    });
    
    // Scene parameters
    let earth, sun, rays = [];
    let animationId;
    let isAnimating = true;
    let rotationAngle = 0; // Current orbit rotation angle in degrees
    let earthRotationAngle = 0; // Earth's own rotation angle
    let stars = []; // Array to store star data
    
    // Real-world relative speeds - using more accurate astronomical values
    const baseOrbitSpeed = 0.0041; // Degrees per frame (approximately 1 degree per day)
    // Earth rotates 365.25 times for each orbit around the sun
    const baseRotationSpeed = baseOrbitSpeed * 365.25; // Degrees per frame for earth's rotation
    let speedMultiplier = 1; // Starting at 1x speed
    let rayInterval = 1; // Angle between rays in degrees
    
    // Update the speed display with current values
    function updateSpeedDisplay() {
      // Calculate days per frame for orbit
      const daysPerFrame = (baseOrbitSpeed * speedMultiplier / 0.9856 * 365.25).toFixed(4);
      
      // Calculate hours per frame for rotation
      const hoursPerFrame = (baseRotationSpeed * speedMultiplier / 15).toFixed(4);
      
      // Calculate time scale (1 second of animation = X days in simulation)
      const timeScale = (speedMultiplier * 0.24).toFixed(2);
      
      // Update the main speed display
      speedValue.textContent = `${speedMultiplier.toLocaleString()}x`;
      
      // Update the detailed values
      hoursValue.textContent = hoursPerFrame;
      daysValue.textContent = daysPerFrame;
      
      // Update the slider value display
      sliderValue.textContent = `${speedMultiplier.toLocaleString()}x`;
      
      // Add time scale information
      speedDetails.innerHTML = `
        Earth rotation: <span id="hoursValue">${hoursPerFrame}</span> hours/frame<br>
        Earth orbit: <span id="daysValue">${daysPerFrame}</span> days/frame<br>
        1 sec ≈ <span>${timeScale}</span> Earth days
      `;
    }
    
    // Generate rays at specified intervals
    function generateRays() {
      rays = [];
      const numRays = Math.floor(360 / rayInterval);
      
      for (let i = 0; i < numRays; i++) {
        const angleDeg = i * rayInterval;
        const angleRad = degToRad(angleDeg);
        
        // Direction vector from the Sun
        const dir = {
          x: Math.cos(angleRad),
          y: Math.sin(angleRad)
        };
        
        // Start point is the center of the sun (will be updated in updateRayEndpoints)
        const start = {
          x: sun.x,
          y: sun.y
        };
        
        // Create ray with initial end point (will be updated)
        // Assign a fixed base opacity with a small random component
        const baseOpacity = 0.2 + 0.05 * Math.random();
        rays.push({
          start: start,
          dir: dir,
          end: { x: start.x, y: start.y }, // Initial value, will be updated
          angle: angleDeg,
          baseOpacity: baseOpacity,
          phase: Math.random() * Math.PI * 2, // Random starting phase for smooth animation
          color: `rgba(255, 215, 0, ${baseOpacity})` 
        });
      }
    }
    
    // Generate stars for the background
    function generateStars() {
      stars = [];
      const numStars = Math.floor(canvas.width * canvas.height / 2000); // Adjust density as needed
      
      for (let i = 0; i < numStars; i++) {
        // Random position across the entire canvas
        const x = Math.random() * canvas.width;
        const y = Math.random() * canvas.height;
        
        // Random size between 0.5 and 2.5, with occasional larger stars
        const size = Math.random() > 0.97 ? 
                    2 + Math.random() * 1.5 : // 3% chance of larger star (2-3.5)
                    0.5 + Math.random() * 1.5; // Normal stars (0.5-2)
        
        // Assign a relative distance (smaller stars are generally further away)
        // This affects parallax movement
        const distance = size < 1.2 ? 
                       2 + Math.random() * 3 : // Distant stars (smaller)
                       0.8 + Math.random() * 1.2; // Closer stars (larger)
        
        // Random base brightness between 0.3 and 0.9
        const baseBrightness = 0.3 + Math.random() * 0.6;
        
        // Random flickering speed - more varied now
        const flickerSpeed = 0.3 + Math.random() * 3;
        
        // Random phase for smooth animation
        const phase = Math.random() * Math.PI * 2;
        
        // Additional phases for multi-wave twinkling
        const phase2 = Math.random() * Math.PI * 2;
        const phase3 = Math.random() * Math.PI * 2;
        
        // Random twinkling pattern type (0-3)
        const twinklePattern = Math.floor(Math.random() * 4);
        
        // Random color (white to slightly blue or yellow)
        const hue = Math.random() > 0.7 ? 
                    (Math.random() > 0.5 ? 210 + Math.random() * 30 : 40 + Math.random() * 20) : 
                    0; // 70% white, 15% blue-ish, 15% yellow-ish
        const saturation = hue === 0 ? 0 : 20 + Math.random() * 30;
        
        // Add glow effect to some stars
        const hasGlow = Math.random() > 0.85; // 15% chance of having glow
        
        // Add movement properties - smaller stars move more
        const moveSpeed = 0.03 + Math.random() * 0.15; // Varied movement speeds
        const moveAngle = Math.random() * Math.PI * 2; // Random direction
        
        // Smaller stars move more, larger stars move less
        const moveRadius = size < 1.5 ? 
                          1 + Math.random() * 2 : // Smaller stars move more
                          0.3 + Math.random() * 0.7; // Larger stars move less
                          
        const movePhase = Math.random() * Math.PI * 2; // Random starting position in movement cycle
        
        // Add a secondary movement for some stars to create more complex patterns
        const hasSecondaryMovement = Math.random() > 0.7; // 30% chance
        const secondaryMoveSpeed = 0.01 + Math.random() * 0.05; // Very slow secondary movement
        const secondaryMoveRadius = 0.2 + Math.random() * 0.8; // Small secondary radius
        const secondaryMovePhase = Math.random() * Math.PI * 2; // Random phase
        
        stars.push({
          x,
          y,
          originalX: x, // Store original position for movement calculations
          originalY: y,
          size,
          baseBrightness,
          flickerSpeed,
          phase,
          phase2,
          phase3,
          twinklePattern,
          hue,
          saturation,
          hasGlow,
          distance,
          moveSpeed,
          moveAngle,
          moveRadius,
          movePhase,
          hasSecondaryMovement,
          secondaryMoveSpeed,
          secondaryMoveRadius,
          secondaryMovePhase
        });
      }
    }
    
    // Initialize the scene
    function initScene() {
      // Clear any existing animation
      if (animationId) {
        cancelAnimationFrame(animationId);
      }
      
      // Calculate center of the canvas
      const centerX = canvas.width / 2;
      const centerY = canvas.height / 2;
      
      // Sun is always at the center
      sun = {
        x: centerX,
        y: centerY,
        r: Math.min(canvas.width, canvas.height) * 0.08 // Responsive sizing
      };
      
      // Get current scroll position for initial earth position
      const scrollY = window.scrollY || 0;
      const parallaxFactor = 0.2;
      
      // Initial earth orbit radius
      const earthOrbitRadius = Math.min(canvas.width, canvas.height) * 0.3;
      
      // Calculate initial ellipse parameters based on scroll
      const baseEccentricity = 0.0167; // Earth's actual orbital eccentricity
      const scrollEccentricity = Math.min(0.2, scrollY * parallaxFactor / earthOrbitRadius);
      const eccentricity = baseEccentricity + scrollEccentricity;
      const semiMajorAxis = earthOrbitRadius;
      const semiMinorAxis = semiMajorAxis * Math.sqrt(1 - eccentricity * eccentricity);
      
      earth = {
        orbitRadius: earthOrbitRadius,
        r: Math.min(canvas.width, canvas.height) * 0.075, // Reduced by half from 0.15
        // Real astronomical parameters
        axialTilt: 23.5, // Earth's axial tilt in degrees
        orbitalInclination: 0, // Earth's orbital inclination (simplified)
        x: centerX + semiMajorAxis, // Initial position (0 degrees)
        y: centerY, // Initial position on elliptical orbit
        rotationAngle: 0, // Initial rotation angle
        seasonalAngle: 0 // Added for seasonal effect
      };
      
      // Reset rotation angles
      rotationAngle = 0;
      // Set initial earth rotation
      earthRotationAngle = 0;
      
      // Generate rays
      generateRays();
      
      // Generate stars
      generateStars();
      
      // Initialize earth position on the elliptical orbit
      updateEarthPosition();
      
      // Initialize ray endpoints
      updateRayEndpoints();
      
      // Update speed display
      updateSpeedDisplay();
      
      // Start animation
      animate();
    }

    // Convert degrees to radians
    function degToRad(deg) {
      return (deg * Math.PI) / 180;
    }

    // Circle-Line intersection
    function lineCircleIntersection(S, D, C, R) {
      const dx = S.x - C.x;
      const dy = S.y - C.y;
      const a = D.x * D.x + D.y * D.y;
      const b = 2 * (dx * D.x + dy * D.y);
      const c = dx * dx + dy * dy - R * R;

      const disc = b * b - 4 * a * c;
      if (disc < 0) return null; // no intersection

      const sqrtDisc = Math.sqrt(disc);
      const t1 = (-b - sqrtDisc) / (2 * a);
      const t2 = (-b + sqrtDisc) / (2 * a);

      // we want the smallest positive t
      let tMin = null;
      if (t1 > 0 && t2 > 0) {
        tMin = Math.min(t1, t2);
      } else if (t1 > 0) {
        tMin = t1;
      } else if (t2 > 0) {
        tMin = t2;
      }
      return tMin;
    }

    // Calculate intersection with canvas edges
    function getCanvasIntersection(S, D) {
      // Check intersection with all 4 edges of the canvas
      const W = canvas.width;
      const H = canvas.height;
      
      // Top edge (y=0)
      let tTop = null;
      if (Math.abs(D.y) > 1e-6) {
        tTop = (0 - S.y) / D.y;
      }
      
      // Bottom edge (y=H)
      let tBottom = null;
      if (Math.abs(D.y) > 1e-6) {
        tBottom = (H - S.y) / D.y;
      }
      
      // Left edge (x=0)
      let tLeft = null;
      if (Math.abs(D.x) > 1e-6) {
        tLeft = (0 - S.x) / D.x;
      }
      
      // Right edge (x=W)
      let tRight = null;
      if (Math.abs(D.x) > 1e-6) {
        tRight = (W - S.x) / D.x;
      }
      
      // Find the smallest positive t
      let tMin = Infinity;
      if (tTop !== null && tTop > 0 && tTop < tMin) tMin = tTop;
      if (tBottom !== null && tBottom > 0 && tBottom < tMin) tMin = tBottom;
      if (tLeft !== null && tLeft > 0 && tLeft < tMin) tMin = tLeft;
      if (tRight !== null && tRight > 0 && tRight < tMin) tMin = tRight;
      
      if (tMin === Infinity) return null;
      
      return tMin;
    }
    
    // Update earth position based on rotation angle
    function updateEarthPosition() {
      const angleRad = degToRad(rotationAngle);
      
      // Get current scroll offset for elliptical orbit calculation
      const scrollY = window.scrollY || 0;
      const parallaxFactor = 0.2;
      
      // Calculate ellipse parameters based on scroll
      // Use the same eccentricity calculation as in updateEarthPosition
      const baseEccentricity = 0.0167; // Earth's actual orbital eccentricity
      const scrollEccentricity = Math.min(0.2, scrollY * parallaxFactor / earth.orbitRadius);
      const eccentricity = baseEccentricity + scrollEccentricity;
      const semiMajorAxis = earth.orbitRadius;
      const semiMinorAxis = semiMajorAxis * Math.sqrt(1 - eccentricity * eccentricity);
      
      // Calculate position on elliptical orbit
      // Parametric equation of ellipse: x = a*cos(t), y = b*sin(t)
      earth.x = sun.x + semiMajorAxis * Math.cos(angleRad);
      earth.y = sun.y + semiMinorAxis * Math.sin(angleRad);
      
      // Update earth's own rotation
      earth.rotationAngle = earthRotationAngle;
      
      // Calculate seasonal effect based on position in orbit
      // This will be used for subtle lighting effects
      earth.seasonalAngle = (rotationAngle + 90) % 360; // Northern hemisphere summer at 90°
    }
    
    // Calculate ray endpoints based on current earth position
    function updateRayEndpoints() {
      for (const ray of rays) {
        // Always update ray start point to current sun position
        ray.start.x = sun.x;
        ray.start.y = sun.y;
        
        // Intersection with Earth
        const tEarth = lineCircleIntersection(ray.start, ray.dir, earth, earth.r);
        
        // Intersection with canvas edges
        const tCanvas = getCanvasIntersection(ray.start, ray.dir);

        // Decide final endpoint
        let tFinal = null;
        if (tEarth !== null && tEarth > 0) {
          // If we have Earth intersection, see if canvas edge is closer
          if (tCanvas !== null) {
            tFinal = Math.min(tEarth, tCanvas);
          } else {
            tFinal = tEarth;
          }
        } else {
          // No Earth intersection => use canvas edge
          tFinal = tCanvas;
        }
        
        // Calculate end point
        if (tFinal !== null && tFinal > 0) {
          ray.end = {
            x: ray.start.x + tFinal * ray.dir.x,
            y: ray.start.y + tFinal * ray.dir.y
          };
        } else {
          ray.end = { x: ray.start.x, y: ray.start.y };
        }
      }
    }
    
    // Draw the Earth with realistic image - improved for seamless wrapping
    function drawEarth() {
      // Draw base Earth (ocean) as fallback
      ctx.fillStyle = '#1565C0'; // Deep blue for oceans
      ctx.beginPath();
      ctx.arc(earth.x, earth.y, earth.r, 0, Math.PI * 2);
      ctx.fill();
      
      if (earthImageLoaded) {
        try {
          // Save the current context state
          ctx.save();
          
          // Create a clipping path for the Earth circle
          ctx.beginPath();
          ctx.arc(earth.x, earth.y, earth.r, 0, Math.PI * 2);
          ctx.clip();
          
          // Calculate the position to draw the image
          const size = earth.r * 2.5; // Make image larger to ensure full coverage
          
          // Translate to earth center
          ctx.translate(earth.x, earth.y);
          
          // Apply Earth's axial tilt
          ctx.rotate(degToRad(earth.axialTilt));
          
          // Calculate the offset based on rotation angle
          // This creates a seamless wrapping effect as the Earth rotates
          const rotationAngleRad = degToRad(earth.rotationAngle);
          const imageWidth = earthImage.width || size;
          
          // Calculate how much to offset the image horizontally based on rotation
          // This creates the illusion of rotating around the y-axis
          const offsetX = -imageWidth * (rotationAngleRad / (Math.PI * 2));
          
          // Draw the image twice side by side to create a seamless wrap
          // First copy - main view
          ctx.drawImage(
            earthImage, 
            -size/2 + offsetX % size, 
            -size/2, 
            size, 
            size
          );
          
          // Second copy - wrapping around the edge
          ctx.drawImage(
            earthImage, 
            -size/2 + offsetX % size + size, 
            -size/2, 
            size, 
            size
          );
          
          // Reset transformation
          ctx.setTransform(1, 0, 0, 1, 0, 0);
          
          // Restore context to remove clipping
          ctx.restore();
        } catch (error) {
          console.error("Error drawing Earth image:", error);
          // The blue circle fallback is already drawn
        }
      }
      
      // Add a subtle atmosphere glow
      // Adjust glow based on seasonal angle to simulate different lighting conditions
      const seasonalFactor = Math.cos(degToRad(earth.seasonalAngle));
      const glowIntensity = 0.3 + seasonalFactor * 0.1; // Brighter in summer, dimmer in winter
      
      const glowGrad = ctx.createRadialGradient(
        earth.x, earth.y, earth.r * 0.9,
        earth.x, earth.y, earth.r * 1.1
      );
      glowGrad.addColorStop(0, `rgba(255, 255, 255, ${glowIntensity})`);
      glowGrad.addColorStop(1, 'rgba(255, 255, 255, 0)');
      
      ctx.fillStyle = glowGrad;
      ctx.beginPath();
      ctx.arc(earth.x, earth.y, earth.r * 1.1, 0, Math.PI * 2);
      ctx.fill();
    }
    
    // Draw the scene
    function drawScene() {
      // Clear canvas
      ctx.fillStyle = '#000';
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      
      // Draw stars
      drawStars();
      
      // Draw orbit path (only the main orbit, not the small ones around Earth)
      ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
      
      // Get current scroll offset for drawing the elliptical orbit
      const scrollY = window.scrollY || 0;
      const parallaxFactor = 0.2;
      
      // Calculate ellipse parameters based on scroll
      // Use the same eccentricity calculation as in updateEarthPosition
      const baseEccentricity = 0.0167; // Earth's actual orbital eccentricity
      const scrollEccentricity = Math.min(0.2, scrollY * parallaxFactor / earth.orbitRadius);
      const eccentricity = baseEccentricity + scrollEccentricity;
      const semiMajorAxis = earth.orbitRadius;
      const semiMinorAxis = semiMajorAxis * Math.sqrt(1 - eccentricity * eccentricity);
      
      // Draw elliptical orbit
      ctx.beginPath();
      
      // Draw the elliptical orbit path point by point
      for (let angle = 0; angle < 360; angle += 5) {
        const angleRad = degToRad(angle);
        const x = sun.x + semiMajorAxis * Math.cos(angleRad);
        const y = sun.y + semiMinorAxis * Math.sin(angleRad);
        
        if (angle === 0) {
          ctx.moveTo(x, y);
        } else {
          ctx.lineTo(x, y);
        }
      }
      
      // Close the path
      ctx.closePath();
      ctx.stroke();
      
      // Draw rays
      ctx.lineWidth = 1;
      for (const ray of rays) {
        ctx.strokeStyle = ray.color;
        ctx.beginPath();
        ctx.moveTo(ray.start.x, ray.start.y);
        ctx.lineTo(ray.end.x, ray.end.y);
        ctx.stroke();
      }
      
      // Draw Earth with realistic image
      drawEarth();
      
      // Draw Sun (yellow circle with gradient)
      const sunGrad = ctx.createRadialGradient(
        sun.x, sun.y, 0,
        sun.x, sun.y, sun.r
      );
      sunGrad.addColorStop(0, 'rgba(255, 255, 255, 1)');
      sunGrad.addColorStop(0.2, 'rgba(255, 255, 0, 1)');
      sunGrad.addColorStop(1, 'rgba(255, 165, 0, 0.8)');
      
      ctx.fillStyle = sunGrad;
      ctx.beginPath();
      ctx.arc(sun.x, sun.y, sun.r, 0, Math.PI * 2);
      ctx.fill();
    }
    
    // Draw stars with flickering effect
    function drawStars() {
      const time = performance.now() * 0.001; // Current time in seconds
      
      // Calculate star movement speed based on Earth's revolution speed
      const earthRevolutionSpeed = baseOrbitSpeed * speedMultiplier;
      const starMovementFactor = earthRevolutionSpeed / 100; // 1/100 of Earth's speed
      
      for (const star of stars) {
        // Calculate current brightness with more randomized flickering effect
        // Use different twinkling patterns based on the star's type
        let combinedFlicker;
        
        switch(star.twinklePattern) {
          case 0: // Simple sine wave
            combinedFlicker = Math.sin(time * star.flickerSpeed + star.phase) * 0.2;
            break;
          case 1: // Multiple sine waves with different frequencies
            combinedFlicker = Math.sin(time * star.flickerSpeed + star.phase) * 0.15 +
                             Math.sin(time * (star.flickerSpeed * 0.7) + star.phase2) * 0.1 +
                             Math.sin(time * (star.flickerSpeed * 1.3) + star.phase3) * 0.05;
            break;
          case 2: // Sharper flicker using absolute sine
            combinedFlicker = Math.abs(Math.sin(time * star.flickerSpeed + star.phase)) * 0.2 - 0.1;
            break;
          case 3: // Subtle random flicker
            combinedFlicker = (Math.sin(time * star.flickerSpeed + star.phase) * 0.1) + 
                             (Math.sin(time * 10 + star.phase2) * 0.05 * Math.sin(time + star.phase3));
            break;
        }
        
        // Apply the combined flicker effect
        const brightness = Math.max(0.1, Math.min(1, star.baseBrightness + combinedFlicker));
        
        // Calculate position with movement tied to Earth's revolution speed
        // Distant stars move less (parallax effect)
        const distanceFactor = 1 / star.distance;
        let moveX = Math.cos(time * star.moveSpeed * starMovementFactor + star.movePhase) * star.moveRadius * distanceFactor;
        let moveY = Math.sin(time * star.moveSpeed * starMovementFactor + star.movePhase + star.moveAngle) * star.moveRadius * distanceFactor;
        
        // Add secondary movement for some stars
        if (star.hasSecondaryMovement) {
          moveX += Math.cos(time * star.secondaryMoveSpeed * starMovementFactor + star.secondaryMovePhase) * star.secondaryMoveRadius * distanceFactor;
          moveY += Math.sin(time * star.secondaryMoveSpeed * starMovementFactor + star.secondaryMovePhase * 1.5) * star.secondaryMoveRadius * distanceFactor;
        }
        
        // Apply movement to position
        const currentX = star.originalX + moveX;
        const currentY = star.originalY + moveY;
        
        // Set the star color with current brightness
        if (star.hue === 0) {
          // White stars
          ctx.fillStyle = `rgba(255, 255, 255, ${brightness})`;
        } else {
          // Colored stars (blue or yellow tint)
          ctx.fillStyle = `hsla(${star.hue}, ${star.saturation}%, 80%, ${brightness})`;
        }
        
        // Draw glow effect for some stars
        if (star.hasGlow) {
          const glowSize = star.size * (2 + Math.sin(time * 0.5 + star.phase) * 0.5);
          const gradient = ctx.createRadialGradient(
            currentX, currentY, 0,
            currentX, currentY, glowSize
          );
          
          if (star.hue === 0) {
            gradient.addColorStop(0, `rgba(255, 255, 255, ${brightness * 0.8})`);
            gradient.addColorStop(1, 'rgba(255, 255, 255, 0)');
          } else {
            gradient.addColorStop(0, `hsla(${star.hue}, ${star.saturation}%, 80%, ${brightness * 0.8})`);
            gradient.addColorStop(1, `hsla(${star.hue}, ${star.saturation}%, 80%, 0)`);
          }
          
          ctx.fillStyle = gradient;
          ctx.beginPath();
          ctx.arc(currentX, currentY, glowSize, 0, Math.PI * 2);
          ctx.fill();
          
          // Reset fill style for the star itself
          if (star.hue === 0) {
            ctx.fillStyle = `rgba(255, 255, 255, ${brightness})`;
          } else {
            ctx.fillStyle = `hsla(${star.hue}, ${star.saturation}%, 80%, ${brightness})`;
          }
        }
        
        // Draw the star
        ctx.beginPath();
        ctx.arc(currentX, currentY, star.size, 0, Math.PI * 2);
        ctx.fill();
      }
    }
    
    // Animation loop
    function animate() {
      if (isAnimating) {
        // Apply speed multiplier to both rotation speeds
        const currentOrbitSpeed = baseOrbitSpeed * speedMultiplier;
        const currentRotationSpeed = baseRotationSpeed * speedMultiplier;
        
        // Update earth orbit position
        rotationAngle = (rotationAngle + currentOrbitSpeed) % 360;
        
        // Update earth's own rotation
        earthRotationAngle = (earthRotationAngle + currentRotationSpeed) % 360;
        
        // Update positions
        updateEarthPosition();
        updateRayEndpoints();
        
        // Subtle animation: smoothly animate ray opacities instead of random flickering
        const time = performance.now() * 0.001; // Current time in seconds
        for (const ray of rays) {
          // Use sine wave to create smooth pulsing effect
          const pulseAmount = Math.sin(time + ray.phase) * 0.05;
          const opacity = Math.max(0.1, Math.min(0.4, ray.baseOpacity + pulseAmount));
          ray.color = `rgba(255, 215, 0, ${opacity})`;
        }
      }
      
      // Always draw the scene, even when orbit animation is paused
      // This ensures stars continue to twinkle and move in the background
      drawScene();
      
      // Continue animation
      animationId = requestAnimationFrame(animate);
    }
    
    // Scroll animation functions
    function handleScroll() {
      const scrollY = window.scrollY;
      const windowHeight = window.innerHeight;
      
      // Clear the timeout if user scrolls before automatic reveal
      if (initialLoadTimeout) {
        clearTimeout(initialLoadTimeout);
        initialLoadTimeout = null;
      }
      
      // Handle visibility based on scroll position
      if (scrollY < 20) {
        // At the very top - show controls, hide content
        hideContent();
        controls.style.opacity = '1';
        speedDisplay.style.opacity = '1';
        
        // Ensure blur is not active at the top
        if (scrollBlur.style.opacity !== '0') {
          setTimeout(() => {
            scrollBlur.style.opacity = '0';
          }, 300);
        }
      } else {
        // Scrolled down - show content, hide controls
        revealContent();
        controls.style.opacity = '0';
        speedDisplay.style.opacity = '0';
      }
      
      // Handle section animations
      const sections = document.querySelectorAll('.section-inner');
      sections.forEach(section => {
        const sectionTop = section.getBoundingClientRect().top;
        if (sectionTop < windowHeight * 0.8) {
          section.classList.add('visible');
        }
      });
      
      // Handle navigation background
      if (scrollY > 50) {
        mainNav.classList.add('scrolled');
      } else {
        mainNav.classList.remove('scrolled');
      }
    }
    
    // Smooth scrolling for navigation links
    function setupSmoothScrolling() {
      const navLinks = document.querySelectorAll('a[href^="#"]');
      
      navLinks.forEach(link => {
        link.addEventListener('click', function(e) {
          e.preventDefault();
          
          const targetId = this.getAttribute('href');
          if (targetId === '#') return;
          
          const targetElement = document.querySelector(targetId);
          if (targetElement) {
            targetElement.scrollIntoView({
              behavior: 'smooth',
              block: 'start'
            });
          }
        });
      });
    }
    
    // Form submission handling
    function setupContactForm() {
      const contactForm = document.querySelector('.contact-form');
      const submitBtn = contactForm.querySelector('.submit-btn');
      
      submitBtn.addEventListener('click', function(e) {
        e.preventDefault();
        
        const nameInput = document.getElementById('name');
        const emailInput = document.getElementById('email');
        const messageInput = document.getElementById('message');
        
        // Simple validation
        if (!nameInput.value || !emailInput.value || !messageInput.value) {
          alert('Please fill in all fields');
          return;
        }
        
        // Here you would typically send the form data to a server
        // For this example, we'll just show a success message
        contactForm.innerHTML = `
          <div style="text-align: center; padding: 30px;">
            <h3>Thank you for your message!</h3>
            <p>I'll get back to you as soon as possible.</p>
          </div>
        `;
      });
    }
    
    // Set up event listeners
    document.addEventListener('DOMContentLoaded', () => {
      const toggleBtn = document.getElementById('toggleAnimation');
      const resetBtn = document.getElementById('resetView');
      const multiplierSlider = document.getElementById('speedMultiplier');
      
      // Toggle animation
      if (toggleBtn) {
        toggleBtn.addEventListener('click', () => {
          isAnimating = !isAnimating;
          toggleBtn.textContent = isAnimating ? 'Pause' : 'Resume';
        });
      }
      
      // Reset view
      if (resetBtn) {
        resetBtn.addEventListener('click', initScene);
      }
      
      // Speed multiplier control
      if (multiplierSlider) {
        multiplierSlider.addEventListener('input', () => {
          speedMultiplier = parseFloat(multiplierSlider.value);
          updateSpeedDisplay();
        });
      }
      
      // Set up scroll animations
      handleScroll(); // Initial call to set up hero animations
      window.addEventListener('scroll', handleScroll);
      
      // Set up smooth scrolling
      setupSmoothScrolling();
      
      // Set up contact form
      setupContactForm();
      
      // Add hover effect to navigation when it's faded
      mainNav.addEventListener('mouseenter', () => {
        mainNav.style.opacity = '1';
      });
      
      mainNav.addEventListener('mouseleave', () => {
        if (window.scrollY < 20) {
          mainNav.style.opacity = '0.2';
        }
      });
      
      // Add hover effect to controls when scrolled down
      controls.addEventListener('mouseenter', () => {
        if (window.scrollY >= 20) {
          controls.style.opacity = '0.7';
        }
      });
      
      controls.addEventListener('mouseleave', () => {
        if (window.scrollY >= 20) {
          controls.style.opacity = '0';
        }
      });
      
      // Add hover effect to speed display when scrolled down
      speedDisplay.addEventListener('mouseenter', () => {
        if (window.scrollY >= 20) {
          speedDisplay.style.opacity = '0.7';
        }
      });
      
      speedDisplay.addEventListener('mouseleave', () => {
        if (window.scrollY >= 20) {
          speedDisplay.style.opacity = '0';
        }
      });
    });
    
    // Parallax effect for solar system based on scroll
    window.addEventListener('scroll', () => {
      const scrollY = window.scrollY;
      
      // Only apply parallax if we have the sun and earth initialized
      if (sun && earth) {
        // Keep sun fixed at the center
        sun.x = canvas.width / 2;
        sun.y = canvas.height / 2;
        
        // Update earth position with new elliptical orbit based on scroll
        updateEarthPosition();
        
        // Update ray endpoints after earth position change
        updateRayEndpoints();
      }
    });
    
    // Scroll blur effect
    let scrollTimeout;
    function handleScrollBlur() {
      // Show the blur effect
      scrollBlur.style.opacity = '1';
      
      // Clear any existing timeout
      clearTimeout(scrollTimeout);
      
      // Set a timeout to hide the blur effect after scrolling stops
      scrollTimeout = setTimeout(() => {
        scrollBlur.style.opacity = '0';
      }, 800); // Fade out 800ms after scrolling stops
    }
    
    // Add scroll event listener for blur effect
    window.addEventListener('scroll', handleScrollBlur);
    
    // Initialize the scene
    initScene();
  </script>
</body>
</html>