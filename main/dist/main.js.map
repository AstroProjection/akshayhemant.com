{"version":3,"file":"main.js","mappings":"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","sources":["webpack://main/./src/index.js"],"sourcesContent":["// Canvas setup\n const canvas = document.getElementById('rayCanvas');\n const ctx = canvas.getContext('2d');\n \n // Speed display elements\n const speedDisplay = document.getElementById('speedDisplay');\n const speedValue = document.getElementById('speedValue');\n const speedDetails = document.getElementById('speedDetails');\n const hoursValue = document.getElementById('hoursValue');\n const daysValue = document.getElementById('daysValue');\n const sliderValue = document.getElementById('sliderValue');\n \n // Content elements\n const heroTitle = document.getElementById('heroTitle');\n const heroSubtitle = document.getElementById('heroSubtitle');\n // const contentContainer = document.querySelector('.content-container');\n const mainNav = document.getElementById('mainNav');\n const controls = document.getElementById('controls');\n const scrollBlur = document.getElementById('scrollBlur');\n \n // Add transitions for smooth appearance/disappearance\n controls.style.transition = 'opacity 0.5s ease';\n speedDisplay.style.transition = 'opacity 0.5s ease';\n mainNav.style.transition = 'opacity 0.5s ease, background 0.3s ease';\n \n // Initially hide all content but show controls\n heroTitle.style.opacity = '0';\n heroSubtitle.style.opacity = '0';\n mainNav.style.opacity = '0.2';\n controls.style.opacity = '1';\n speedDisplay.style.opacity = '1';\n \n // Set a timer to show initial content after a delay if user hasn't scrolled\n let initialLoadTimeout = setTimeout(() => {\n   if (window.scrollY < 10) { // Only reveal if user hasn't scrolled much\n     // Keep controls visible, content hidden at top\n   } else {\n     // If they've scrolled, show content\n     revealContent();\n   }\n }, 3000); // 3 seconds delay\n \n // Function to reveal content\n function revealContent() {\n   mainNav.style.opacity = '1';\n   \n   // Staggered animation for hero elements\n   heroTitle.style.opacity = '1';\n   heroTitle.style.transform = 'translateY(0)';\n   \n   initialLoadTimeout = setTimeout(() => {\n     heroSubtitle.style.opacity = '1';\n     heroSubtitle.style.transform = 'translateY(0)';\n   }, 300);\n }\n \n // Function to hide content\n function hideContent() {\n   heroTitle.style.opacity = '0';\n   heroTitle.style.transform = 'translateY(30px)';\n   heroSubtitle.style.opacity = '0';\n   heroSubtitle.style.transform = 'translateY(30px)';\n   mainNav.style.opacity = '0.2';\n   clearTimeout(initialLoadTimeout);\n }\n \n // Earth image - using a more reliable source and adding error handling\n const earthImage = new Image();\n earthImage.crossOrigin = \"Anonymous\"; // Handle CORS issues\n earthImage.src = \"../assets/earth.jpg\";\n \n // Alternative URLs if the first one fails\n const fallbackUrls = [\n   'https://upload.wikimedia.org/wikipedia/commons/thumb/c/c3/Earth_from_space_north_pole.jpg/1200px-Earth_from_space_north_pole.jpg',\n   'https://eoimages.gsfc.nasa.gov/images/imagerecords/73000/73909/world.topo.bathy.200412.3x5400x2700.jpg'\n ];\n \n let currentUrlIndex = 0;\n let earthImageLoaded = false;\n \n // Success handler\n earthImage.onload = function() {\n   console.log(\"Earth image loaded successfully\");\n   earthImageLoaded = true;\n   if (earth) {\n     drawScene(); // Redraw once image is loaded\n   }\n };\n \n // Error handler - try fallback URLs\n earthImage.onerror = function() {\n   console.log(\"Error loading Earth image, trying fallback\");\n   currentUrlIndex++;\n   if (currentUrlIndex < fallbackUrls.length) {\n     earthImage.src = fallbackUrls[currentUrlIndex];\n   } else {\n     console.log(\"All Earth image URLs failed\");\n   }\n };\n \n // Set canvas to full window size\n function resizeCanvas() {\n   canvas.width = window.innerWidth;\n   canvas.height = window.innerHeight;\n }\n \n // Call resize initially and on window resize\n resizeCanvas();\n window.addEventListener('resize', () => {\n   resizeCanvas();\n   initScene(); // Reinitialize scene on resize\n });\n \n // Scene parameters\n let earth, sun, rays = [];\n let animationId;\n let isAnimating = true;\n let rotationAngle = 0; // Current orbit rotation angle in degrees\n let earthRotationAngle = 0; // Earth's own rotation angle\n let stars = []; // Array to store star data\n \n // Real-world relative speeds - using more accurate astronomical values\n const baseOrbitSpeed = 0.0041; // Degrees per frame (approximately 1 degree per day)\n // Earth rotates 365.25 times for each orbit around the sun\n const baseRotationSpeed = baseOrbitSpeed * 24; // Degrees per frame for earth's rotation\n let speedMultiplier = 1; // Starting at 1x speed\n let rayInterval = 1; // Angle between rays in degrees\n \n // Update the speed display with current values\n function updateSpeedDisplay() {\n   // Calculate days per frame for orbit\n   const daysPerFrame = (baseOrbitSpeed * speedMultiplier / 0.9856 * 365.25).toFixed(4);\n   \n   // Calculate hours per frame for rotation\n   const hoursPerFrame = (baseRotationSpeed * speedMultiplier / 15).toFixed(4);\n   \n   // Calculate time scale (1 second of animation = X days in simulation)\n   const timeScale = (speedMultiplier * 0.24).toFixed(2);\n   \n   // Update the main speed display\n   speedValue.textContent = `${speedMultiplier.toLocaleString()}x`;\n   \n   // Update the detailed values\n   hoursValue.textContent = hoursPerFrame;\n   daysValue.textContent = daysPerFrame;\n   \n   // Update the slider value display\n   sliderValue.textContent = `${speedMultiplier.toLocaleString()}x`;\n   \n   // Add time scale information\n   speedDetails.innerHTML = `\n     Earth rotation: <span id=\"hoursValue\">${hoursPerFrame}</span> hours/frame<br>\n     Earth orbit: <span id=\"daysValue\">${daysPerFrame}</span> days/frame<br>\n     1 sec ≈ <span>${timeScale}</span> Earth days\n   `;\n }\n \n // Generate rays at specified intervals\n function generateRays() {\n   rays = [];\n   const numRays = Math.floor(360 / rayInterval);\n   \n   for (let i = 0; i < numRays; i++) {\n     const angleDeg = i * rayInterval;\n     const angleRad = degToRad(angleDeg);\n     \n     // Direction vector from the Sun\n     const dir = {\n       x: Math.cos(angleRad),\n       y: Math.sin(angleRad)\n     };\n     \n     // Start point is the center of the sun (will be updated in updateRayEndpoints)\n     const start = {\n       x: sun.x,\n       y: sun.y\n     };\n     \n     // Create ray with initial end point (will be updated)\n     // Assign a fixed base opacity with a small random component\n     const baseOpacity = 0.2 + 0.05 * Math.random();\n     rays.push({\n       start: start,\n       dir: dir,\n       end: { x: start.x, y: start.y }, // Initial value, will be updated\n       angle: angleDeg,\n       baseOpacity: baseOpacity,\n       phase: Math.random() * Math.PI * 2, // Random starting phase for smooth animation\n       color: `rgba(255, 215, 0, ${baseOpacity})` \n     });\n   }\n }\n \n // Generate stars for the background\n function generateStars() {\n   stars = [];\n   const numStars = Math.floor(canvas.width * canvas.height / 2000); // Adjust density as needed\n   \n   for (let i = 0; i < numStars; i++) {\n     // Random position across the entire canvas\n     const x = Math.random() * canvas.width;\n     const y = Math.random() * canvas.height;\n     \n     // Random size between 0.5 and 2.5, with occasional larger stars\n     const size = Math.random() > 0.97 ? \n                 2 + Math.random() * 1.5 : // 3% chance of larger star (2-3.5)\n                 0.5 + Math.random() * 1.5; // Normal stars (0.5-2)\n     \n     // Assign a relative distance (smaller stars are generally further away)\n     // This affects parallax movement\n     const distance = size < 1.2 ? \n                    2 + Math.random() * 3 : // Distant stars (smaller)\n                    0.8 + Math.random() * 1.2; // Closer stars (larger)\n     \n     // Random base brightness between 0.3 and 0.9\n     const baseBrightness = 0.3 + Math.random() * 0.6;\n     \n     // Random flickering speed - more varied now\n     const flickerSpeed = 0.3 + Math.random() * 3;\n     \n     // Random phase for smooth animation\n     const phase = Math.random() * Math.PI * 2;\n     \n     // Additional phases for multi-wave twinkling\n     const phase2 = Math.random() * Math.PI * 2;\n     const phase3 = Math.random() * Math.PI * 2;\n     \n     // Random twinkling pattern type (0-3)\n     const twinklePattern = Math.floor(Math.random() * 4);\n     \n     // Random color (white to slightly blue or yellow)\n     const hue = Math.random() > 0.7 ? \n                 (Math.random() > 0.5 ? 210 + Math.random() * 30 : 40 + Math.random() * 20) : \n                 0; // 70% white, 15% blue-ish, 15% yellow-ish\n     const saturation = hue === 0 ? 0 : 20 + Math.random() * 30;\n     \n     // Add glow effect to some stars\n     const hasGlow = Math.random() > 0.85; // 15% chance of having glow\n     \n     // Add movement properties - smaller stars move more\n     const moveSpeed = 0.03 + Math.random() * 0.15; // Varied movement speeds\n     const moveAngle = Math.random() * Math.PI * 2; // Random direction\n     \n     // Smaller stars move more, larger stars move less\n     const moveRadius = size < 1.5 ? \n                       1 + Math.random() * 2 : // Smaller stars move more\n                       0.3 + Math.random() * 0.7; // Larger stars move less\n                       \n     const movePhase = Math.random() * Math.PI * 2; // Random starting position in movement cycle\n     \n     // Add a secondary movement for some stars to create more complex patterns\n     const hasSecondaryMovement = Math.random() > 0.7; // 30% chance\n     const secondaryMoveSpeed = 0.01 + Math.random() * 0.05; // Very slow secondary movement\n     const secondaryMoveRadius = 0.2 + Math.random() * 0.8; // Small secondary radius\n     const secondaryMovePhase = Math.random() * Math.PI * 2; // Random phase\n     \n     stars.push({\n       x,\n       y,\n       originalX: x, // Store original position for movement calculations\n       originalY: y,\n       size,\n       baseBrightness,\n       flickerSpeed,\n       phase,\n       phase2,\n       phase3,\n       twinklePattern,\n       hue,\n       saturation,\n       hasGlow,\n       distance,\n       moveSpeed,\n       moveAngle,\n       moveRadius,\n       movePhase,\n       hasSecondaryMovement,\n       secondaryMoveSpeed,\n       secondaryMoveRadius,\n       secondaryMovePhase\n     });\n   }\n }\n \n // Initialize the scene\n function initScene() {\n   // Clear any existing animation\n   if (animationId) {\n     cancelAnimationFrame(animationId);\n   }\n   \n   // Calculate center of the canvas\n   const centerX = canvas.width / 2;\n   const centerY = canvas.height / 2;\n   \n   // Sun is always at the center\n   sun = {\n     x: centerX,\n     y: centerY,\n     r: Math.min(canvas.width, canvas.height) * 0.08 // Responsive sizing\n   };\n   \n   // Get current scroll position for initial earth position\n   const scrollY = window.scrollY || 0;\n   const parallaxFactor = 0.2;\n   \n   // Initial earth orbit radius\n   const earthOrbitRadius = Math.min(canvas.width, canvas.height) * 0.3;\n   \n   // Calculate initial ellipse parameters based on scroll\n   const baseEccentricity = 0.0167; // Earth's actual orbital eccentricity\n   const maxScrollEccentricity = 5; // Maximum eccentricity based on scroll\n   const scrollEccentricity = Math.min(maxScrollEccentricity, scrollY * parallaxFactor / earthOrbitRadius);\n   const eccentricity = baseEccentricity + scrollEccentricity; // Update eccentricity based on scroll\n   const semiMajorAxis = earthOrbitRadius;\n   const semiMinorAxis = semiMajorAxis * Math.sqrt(1 - eccentricity * eccentricity);\n   \n   earth = {\n     orbitRadius: earthOrbitRadius,\n     r: Math.min(canvas.width, canvas.height) * 0.075, // Reduced by half from 0.15\n     // Real astronomical parameters\n     axialTilt: 23.5, // Earth's axial tilt in degrees\n     orbitalInclination: 0, // Earth's orbital inclination (simplified)\n     x: centerX + semiMajorAxis * Math.cos(degToRad(rotationAngle)), // Initial position (0 degrees)\n     y: centerY + semiMinorAxis * Math.sin(degToRad(rotationAngle)), // Initial position on elliptical orbit\n     rotationAngle: 0, // Initial rotation angle\n     seasonalAngle: 0 // Added for seasonal effect\n   };\n   \n   // Reset rotation angles\n   rotationAngle = 0;\n   // Set initial earth rotation\n   earthRotationAngle = 0;\n   \n   // Generate rays\n   generateRays();\n   \n   // Generate stars\n   generateStars();\n   \n   // Initialize earth position on the elliptical orbit\n   updateEarthPosition();\n   \n   // Initialize ray endpoints\n   updateRayEndpoints();\n   \n   // Update speed display\n   updateSpeedDisplay();\n   \n   // Start animation\n   animate();\n }\n\n // Convert degrees to radians\n function degToRad(deg) {\n   return (deg * Math.PI) / 180;\n }\n\n // Circle-Line intersection\n function lineCircleIntersection(S, D, C, R) {\n   const dx = S.x - C.x;\n   const dy = S.y - C.y;\n   const a = D.x * D.x + D.y * D.y;\n   const b = 2 * (dx * D.x + dy * D.y);\n   const c = dx * dx + dy * dy - R * R;\n\n   const disc = b * b - 4 * a * c;\n   if (disc < 0) return null; // no intersection\n\n   const sqrtDisc = Math.sqrt(disc);\n   const t1 = (-b - sqrtDisc) / (2 * a);\n   const t2 = (-b + sqrtDisc) / (2 * a);\n\n   // we want the smallest positive t\n   let tMin = null;\n   if (t1 > 0 && t2 > 0) {\n     tMin = Math.min(t1, t2);\n   } else if (t1 > 0) {\n     tMin = t1;\n   } else if (t2 > 0) {\n     tMin = t2;\n   }\n   return tMin;\n }\n\n // Calculate intersection with canvas edges\n function getCanvasIntersection(S, D) {\n   // Check intersection with all 4 edges of the canvas\n   const W = canvas.width;\n   const H = canvas.height;\n   \n   // Top edge (y=0)\n   let tTop = null;\n   if (Math.abs(D.y) > 1e-6) {\n     tTop = (0 - S.y) / D.y;\n   }\n   \n   // Bottom edge (y=H)\n   let tBottom = null;\n   if (Math.abs(D.y) > 1e-6) {\n     tBottom = (H - S.y) / D.y;\n   }\n   \n   // Left edge (x=0)\n   let tLeft = null;\n   if (Math.abs(D.x) > 1e-6) {\n     tLeft = (0 - S.x) / D.x;\n   }\n   \n   // Right edge (x=W)\n   let tRight = null;\n   if (Math.abs(D.x) > 1e-6) {\n     tRight = (W - S.x) / D.x;\n   }\n   \n   // Find the smallest positive t\n   let tMin = Infinity;\n   if (tTop !== null && tTop > 0 && tTop < tMin) tMin = tTop;\n   if (tBottom !== null && tBottom > 0 && tBottom < tMin) tMin = tBottom;\n   if (tLeft !== null && tLeft > 0 && tLeft < tMin) tMin = tLeft;\n   if (tRight !== null && tRight > 0 && tRight < tMin) tMin = tRight;\n   \n   if (tMin === Infinity) return null;\n   \n   return tMin;\n }\n \n // Update earth position based on rotation angle\n function updateEarthPosition() {\n   const angleRad = degToRad(rotationAngle);\n   \n   // Get current scroll offset for elliptical orbit calculation\n   const scrollY = window.scrollY || 0;\n   const parallaxFactor = 0.2;\n   \n   // Calculate ellipse parameters based on scroll\n   // Use the same eccentricity calculation as in updateEarthPosition\n   const baseEccentricity = 0.0167; // Earth's actual orbital eccentricity\n   const scrollEccentricity = Math.min(0.2, scrollY * parallaxFactor / earth.orbitRadius);\n   const eccentricity = baseEccentricity + scrollEccentricity;\n   const semiMajorAxis = earth.orbitRadius;\n   const semiMinorAxis = semiMajorAxis * Math.sqrt(1 - eccentricity * eccentricity);\n   \n   // Calculate position on elliptical orbit\n   // Parametric equation of ellipse: x = a*cos(t), y = b*sin(t)\n   earth.x = sun.x + semiMajorAxis * Math.cos(angleRad);\n   earth.y = sun.y + semiMinorAxis * Math.sin(angleRad);\n   \n   // Update earth's own rotation\n   earth.rotationAngle = earthRotationAngle;\n   \n   // Calculate seasonal effect based on position in orbit\n   // This will be used for subtle lighting effects\n   earth.seasonalAngle = (rotationAngle + 90) % 360; // Northern hemisphere summer at 90°\n }\n \n // Calculate ray endpoints based on current earth position\n function updateRayEndpoints() {\n   for (const ray of rays) {\n     // Always update ray start point to current sun position\n     ray.start.x = sun.x;\n     ray.start.y = sun.y;\n     \n     // Intersection with Earth\n     const tEarth = lineCircleIntersection(ray.start, ray.dir, earth, earth.r);\n     \n     // Intersection with canvas edges\n     const tCanvas = getCanvasIntersection(ray.start, ray.dir);\n\n     // Decide final endpoint\n     let tFinal = null;\n     if (tEarth !== null && tEarth > 0) {\n       // If we have Earth intersection, see if canvas edge is closer\n       if (tCanvas !== null) {\n         tFinal = Math.min(tEarth, tCanvas);\n       } else {\n         tFinal = tEarth;\n       }\n     } else {\n       // No Earth intersection => use canvas edge\n       tFinal = tCanvas;\n     }\n     \n     // Calculate end point\n     if (tFinal !== null && tFinal > 0) {\n       ray.end = {\n         x: ray.start.x + tFinal * ray.dir.x,\n         y: ray.start.y + tFinal * ray.dir.y\n       };\n     } else {\n       ray.end = { x: ray.start.x, y: ray.start.y };\n     }\n   }\n }\n \n // Draw the Earth with realistic image - improved for seamless wrapping\n function drawEarth() {\n   // Draw base Earth (ocean) as fallback\n   ctx.fillStyle = '#1565C0'; // Deep blue for oceans\n   ctx.beginPath();\n   ctx.arc(earth.x, earth.y, earth.r, 0, Math.PI * 2);\n   ctx.fill();\n   \n   if (earthImageLoaded) {\n     try {\n       // Save the current context state\n       ctx.save();\n       \n       // Create a clipping path for the Earth circle\n       ctx.beginPath();\n       ctx.arc(earth.x, earth.y, earth.r, 0, Math.PI * 2);\n       ctx.clip();\n       \n       // Calculate the position to draw the image\n       const size = earth.r * 2.5; // Make image larger to ensure full coverage\n       \n       // Translate to earth center\n       ctx.translate(earth.x, earth.y);\n       \n       // Apply Earth's axial tilt\n       ctx.rotate(degToRad(earth.axialTilt));\n       \n       // Calculate the offset based on rotation angle\n       // This creates a seamless wrapping effect as the Earth rotates\n       const rotationAngleRad = degToRad(earth.rotationAngle);\n       const imageWidth = earthImage.width || size;\n       \n       // Calculate how much to offset the image horizontally based on rotation\n       // This creates the illusion of rotating around the y-axis\n       const offsetX = -imageWidth * (rotationAngleRad / (Math.PI * 2));\n       \n       // Draw the image twice side by side to create a seamless wrap\n       // First copy - main view\n       ctx.drawImage(\n         earthImage, \n         -size/2 + offsetX % size, \n         -size/2, \n         size, \n         size\n       );\n       \n       // Second copy - wrapping around the edge\n       ctx.drawImage(\n         earthImage, \n         -size/2 + offsetX % size + size, \n         -size/2, \n         size, \n         size\n       );\n       \n       // Reset transformation\n       ctx.setTransform(1, 0, 0, 1, 0, 0);\n       \n       // Restore context to remove clipping\n       ctx.restore();\n     } catch (error) {\n       console.error(\"Error drawing Earth image:\", error);\n       // The blue circle fallback is already drawn\n     }\n   }\n   \n   // Add a subtle atmosphere glow\n   // Adjust glow based on seasonal angle to simulate different lighting conditions\n   const seasonalFactor = Math.cos(degToRad(earth.seasonalAngle));\n   const glowIntensity = 0.3 + seasonalFactor * 0.1; // Brighter in summer, dimmer in winter\n   \n   const glowGrad = ctx.createRadialGradient(\n     earth.x, earth.y, earth.r * 0.9,\n     earth.x, earth.y, earth.r * 1.1\n   );\n   glowGrad.addColorStop(0, `rgba(255, 255, 255, ${glowIntensity})`);\n   glowGrad.addColorStop(1, 'rgba(255, 255, 255, 0)');\n   \n   ctx.fillStyle = glowGrad;\n   ctx.beginPath();\n   ctx.arc(earth.x, earth.y, earth.r * 1.1, 0, Math.PI * 2);\n   ctx.fill();\n }\n \n // Draw the scene\n function drawScene() {\n   // Clear canvas\n   ctx.fillStyle = '#000';\n   ctx.fillRect(0, 0, canvas.width, canvas.height);\n   \n   // Draw stars\n   drawStars();\n   \n   // Draw orbit path (only the main orbit, not the small ones around Earth)\n   ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';\n   \n   // Get current scroll offset for drawing the elliptical orbit\n   const scrollY = window.scrollY || 0;\n   const parallaxFactor = 0.2;\n   \n   // Calculate ellipse parameters based on scroll\n   // Use the same eccentricity calculation as in updateEarthPosition\n   const baseEccentricity = 0.0167; // Earth's actual orbital eccentricity\n   const scrollEccentricity = Math.min(0.2, scrollY * parallaxFactor / earth.orbitRadius);\n   const eccentricity = baseEccentricity + scrollEccentricity;\n   const semiMajorAxis = earth.orbitRadius;\n   const semiMinorAxis = semiMajorAxis * Math.sqrt(1 - eccentricity * eccentricity);\n   \n   // Draw elliptical orbit\n   ctx.beginPath();\n   \n   // Draw the elliptical orbit path point by point\n   for (let angle = 0; angle < 360; angle += 5) {\n     const angleRad = degToRad(angle);\n     const x = sun.x + semiMajorAxis * Math.cos(angleRad);\n     const y = sun.y + semiMinorAxis * Math.sin(angleRad);\n     \n     if (angle === 0) {\n       ctx.moveTo(x, y);\n     } else {\n       ctx.lineTo(x, y);\n     }\n   }\n   \n   // Close the path\n   ctx.closePath();\n   ctx.stroke();\n   \n   // Draw rays\n   ctx.lineWidth = 1;\n   for (const ray of rays) {\n     ctx.strokeStyle = ray.color;\n     ctx.beginPath();\n     ctx.moveTo(ray.start.x, ray.start.y);\n     ctx.lineTo(ray.end.x, ray.end.y);\n     ctx.stroke();\n   }\n   \n   // Draw Earth with realistic image\n   drawEarth();\n   \n   // Draw Sun (yellow circle with gradient)\n   const sunGrad = ctx.createRadialGradient(\n     sun.x, sun.y, 0,\n     sun.x, sun.y, sun.r\n   );\n   sunGrad.addColorStop(0, 'rgba(255, 255, 255, 1)');\n   sunGrad.addColorStop(0.2, 'rgba(255, 255, 0, 1)');\n   sunGrad.addColorStop(1, 'rgba(255, 165, 0, 0.8)');\n   \n   ctx.fillStyle = sunGrad;\n   ctx.beginPath();\n   ctx.arc(sun.x, sun.y, sun.r, 0, Math.PI * 2);\n   ctx.fill();\n }\n \n // Draw stars with flickering effect\n function drawStars() {\n   const time = performance.now() * 0.001; // Current time in seconds\n   \n   // Calculate star movement speed based on Earth's revolution speed\n   const earthRevolutionSpeed = baseOrbitSpeed * speedMultiplier;\n   const starMovementFactor = earthRevolutionSpeed / 100; // 1/100 of Earth's speed\n   \n   for (const star of stars) {\n     // Calculate current brightness with more randomized flickering effect\n     // Use different twinkling patterns based on the star's type\n     let combinedFlicker;\n     \n     switch(star.twinklePattern) {\n       case 0: // Simple sine wave\n         combinedFlicker = Math.sin(time * star.flickerSpeed + star.phase) * 0.2;\n         break;\n       case 1: // Multiple sine waves with different frequencies\n         combinedFlicker = Math.sin(time * star.flickerSpeed + star.phase) * 0.15 +\n                          Math.sin(time * (star.flickerSpeed * 0.7) + star.phase2) * 0.1 +\n                          Math.sin(time * (star.flickerSpeed * 1.3) + star.phase3) * 0.05;\n         break;\n       case 2: // Sharper flicker using absolute sine\n         combinedFlicker = Math.abs(Math.sin(time * star.flickerSpeed + star.phase)) * 0.2 - 0.1;\n         break;\n       case 3: // Subtle random flicker\n         combinedFlicker = (Math.sin(time * star.flickerSpeed + star.phase) * 0.1) + \n                          (Math.sin(time * 10 + star.phase2) * 0.05 * Math.sin(time + star.phase3));\n         break;\n     }\n     \n     // Apply the combined flicker effect\n     const brightness = Math.max(0.1, Math.min(1, star.baseBrightness + combinedFlicker));\n     \n     // Calculate position with movement tied to Earth's revolution speed\n     // Distant stars move less (parallax effect)\n     const distanceFactor = 1 / star.distance;\n     let moveX = Math.cos(time * star.moveSpeed * starMovementFactor + star.movePhase) * star.moveRadius * distanceFactor;\n     let moveY = Math.sin(time * star.moveSpeed * starMovementFactor + star.movePhase + star.moveAngle) * star.moveRadius * distanceFactor;\n     \n     // Add secondary movement for some stars\n     if (star.hasSecondaryMovement) {\n       moveX += Math.cos(time * star.secondaryMoveSpeed * starMovementFactor + star.secondaryMovePhase) * star.secondaryMoveRadius * distanceFactor;\n       moveY += Math.sin(time * star.secondaryMoveSpeed * starMovementFactor + star.secondaryMovePhase * 1.5) * star.secondaryMoveRadius * distanceFactor;\n     }\n     \n     // Apply movement to position\n     const currentX = star.originalX + moveX;\n     const currentY = star.originalY + moveY;\n     \n     // Set the star color with current brightness\n     if (star.hue === 0) {\n       // White stars\n       ctx.fillStyle = `rgba(255, 255, 255, ${brightness})`;\n     } else {\n       // Colored stars (blue or yellow tint)\n       ctx.fillStyle = `hsla(${star.hue}, ${star.saturation}%, 80%, ${brightness})`;\n     }\n     \n     // Draw glow effect for some stars\n     if (star.hasGlow) {\n       const glowSize = star.size * (2 + Math.sin(time * 0.5 + star.phase) * 0.5);\n       const gradient = ctx.createRadialGradient(\n         currentX, currentY, 0,\n         currentX, currentY, glowSize\n       );\n       \n       if (star.hue === 0) {\n         gradient.addColorStop(0, `rgba(255, 255, 255, ${brightness * 0.8})`);\n         gradient.addColorStop(1, 'rgba(255, 255, 255, 0)');\n       } else {\n         gradient.addColorStop(0, `hsla(${star.hue}, ${star.saturation}%, 80%, ${brightness * 0.8})`);\n         gradient.addColorStop(1, `hsla(${star.hue}, ${star.saturation}%, 80%, 0)`);\n       }\n       \n       ctx.fillStyle = gradient;\n       ctx.beginPath();\n       ctx.arc(currentX, currentY, glowSize, 0, Math.PI * 2);\n       ctx.fill();\n       \n       // Reset fill style for the star itself\n       if (star.hue === 0) {\n         ctx.fillStyle = `rgba(255, 255, 255, ${brightness})`;\n       } else {\n         ctx.fillStyle = `hsla(${star.hue}, ${star.saturation}%, 80%, ${brightness})`;\n       }\n     }\n     \n     // Draw the star\n     ctx.beginPath();\n     ctx.arc(currentX, currentY, star.size, 0, Math.PI * 2);\n     ctx.fill();\n   }\n }\n \n // Animation loop\n function animate() {\n   if (isAnimating) {\n     // Apply speed multiplier to both rotation speeds\n     const currentOrbitSpeed = baseOrbitSpeed * speedMultiplier;\n     const currentRotationSpeed = baseRotationSpeed * speedMultiplier;\n     \n     // Update earth orbit position\n     rotationAngle = (rotationAngle + currentOrbitSpeed) % 360;\n     \n     // Update earth's own rotation\n     earthRotationAngle = (earthRotationAngle + currentRotationSpeed) % 360;\n     \n     // Update positions\n     updateEarthPosition();\n     updateRayEndpoints();\n     \n     // Subtle animation: smoothly animate ray opacities instead of random flickering\n     const time = performance.now() * 0.001; // Current time in seconds\n     for (const ray of rays) {\n       // Use sine wave to create smooth pulsing effect\n       const pulseAmount = Math.sin(time + ray.phase) * 0.05;\n       const opacity = Math.max(0.1, Math.min(0.4, ray.baseOpacity + pulseAmount));\n       ray.color = `rgba(255, 215, 0, ${opacity})`;\n     }\n   }\n   \n   // Always draw the scene, even when orbit animation is paused\n   // This ensures stars continue to twinkle and move in the background\n   drawScene();\n   \n   // Continue animation\n   animationId = requestAnimationFrame(animate);\n }\n \n // Scroll animation functions\n function handleScroll() {\n   const scrollY = window.scrollY;\n   const windowHeight = window.innerHeight;\n   \n   // Clear the timeout if user scrolls before automatic reveal\n   if (initialLoadTimeout) {\n     clearTimeout(initialLoadTimeout);\n     initialLoadTimeout = null;\n   }\n   \n   // Handle visibility based on scroll position\n   if (scrollY < 20) {\n     // At the very top - show controls, hide content\n     hideContent();\n     controls.style.opacity = '1';\n     speedDisplay.style.opacity = '1';\n     \n     // Ensure blur is not active at the top\n     if (scrollBlur.style.opacity !== '0') {\n       setTimeout(() => {\n         scrollBlur.style.opacity = '0';\n       }, 300);\n     }\n   } else {\n     // Scrolled down - show content, hide controls\n     revealContent();\n     controls.style.opacity = '0';\n     speedDisplay.style.opacity = '0';\n   }\n   \n   // Handle section animations\n   const sections = document.querySelectorAll('.section-inner');\n   sections.forEach(section => {\n     const sectionTop = section.getBoundingClientRect().top;\n     if (sectionTop < windowHeight * 0.8) {\n       section.classList.add('visible');\n     }\n   });\n   \n   // Handle navigation background\n   if (scrollY > 50) {\n     mainNav.classList.add('scrolled');\n   } else {\n     mainNav.classList.remove('scrolled');\n   }\n }\n \n // Smooth scrolling for navigation links\n function setupSmoothScrolling() {\n   const navLinks = document.querySelectorAll('a[href^=\"#\"]');\n   \n   navLinks.forEach(link => {\n     link.addEventListener('click', function(e) {\n       e.preventDefault();\n       \n       const targetId = this.getAttribute('href');\n       if (targetId === '#') return;\n       \n       const targetElement = document.querySelector(targetId);\n       if (targetElement) {\n         targetElement.scrollIntoView({\n           behavior: 'smooth',\n           block: 'start'\n         });\n       }\n     });\n   });\n }\n \n // Set up event listeners\n document.addEventListener('DOMContentLoaded', () => {\n   const toggleBtn = document.getElementById('toggleAnimation');\n   const resetBtn = document.getElementById('resetView');\n   const multiplierSlider = document.getElementById('speedMultiplier');\n   \n   // Toggle animation\n   if (toggleBtn) {\n     toggleBtn.addEventListener('click', () => {\n       isAnimating = !isAnimating;\n       toggleBtn.textContent = isAnimating ? 'Pause' : 'Resume';\n     });\n   }\n   \n   // Reset view\n   if (resetBtn) {\n     resetBtn.addEventListener('click', initScene);\n   }\n   \n   // Speed multiplier control\n   if (multiplierSlider) {\n     multiplierSlider.addEventListener('input', () => {\n       speedMultiplier = parseFloat(multiplierSlider.value);\n       updateSpeedDisplay();\n     });\n   }\n   \n   // Set up scroll animations\n   handleScroll(); // Initial call to set up hero animations\n   window.addEventListener('scroll', handleScroll);\n   \n   // Set up smooth scrolling\n   setupSmoothScrolling();\n   \n   // Add hover effect to navigation when it's faded\n   mainNav.addEventListener('mouseenter', () => {\n     mainNav.style.opacity = '1';\n   });\n   \n   mainNav.addEventListener('mouseleave', () => {\n     if (window.scrollY < 20) {\n       mainNav.style.opacity = '0.2';\n     }\n   });\n   \n   // Add hover effect to controls when scrolled down\n   controls.addEventListener('mouseenter', () => {\n     if (window.scrollY >= 20) {\n       controls.style.opacity = '0.7';\n     }\n   });\n   \n   controls.addEventListener('mouseleave', () => {\n     if (window.scrollY >= 20) {\n       controls.style.opacity = '0';\n     }\n   });\n   \n   // Add hover effect to speed display when scrolled down\n   speedDisplay.addEventListener('mouseenter', () => {\n     if (window.scrollY >= 20) {\n       speedDisplay.style.opacity = '0.7';\n     }\n   });\n   \n   speedDisplay.addEventListener('mouseleave', () => {\n     if (window.scrollY >= 20) {\n       speedDisplay.style.opacity = '0';\n     }\n   });\n });\n \n // Parallax effect for solar system based on scroll\n window.addEventListener('scroll', () => {\n   const scrollY = window.scrollY;\n   \n   // Only apply parallax if we have the sun and earth initialized\n   if (sun && earth) {\n     // Keep sun fixed at the center\n     sun.x = canvas.width / 2;\n     sun.y = canvas.height / 2;\n     \n     // Update earth position with new elliptical orbit based on scroll\n     updateEarthPosition();\n     \n     // Update ray endpoints after earth position change\n     updateRayEndpoints();\n   }\n });\n \n // Scroll blur effect\n let scrollTimeout;\n function handleScrollBlur() {\n   // Show the blur effect\n   scrollBlur.style.opacity = '1';\n   \n   // Clear any existing timeout\n   clearTimeout(scrollTimeout);\n   \n   // Set a timeout to hide the blur effect after scrolling stops\n   scrollTimeout = setTimeout(() => {\n     scrollBlur.style.opacity = '0';\n   }, 800); // Fade out 800ms after scrolling stops\n }\n \n // Add scroll event listener for blur effect\n window.addEventListener('scroll', handleScrollBlur);\n \n // Initialize the scene\n initScene();\n"],"names":["canvas","document","getElementById","ctx","getContext","speedDisplay","speedValue","speedDetails","hoursValue","daysValue","sliderValue","heroTitle","heroSubtitle","mainNav","controls","scrollBlur","style","transition","opacity","initialLoadTimeout","setTimeout","window","scrollY","revealContent","transform","earthImage","Image","crossOrigin","src","fallbackUrls","currentUrlIndex","earthImageLoaded","resizeCanvas","width","innerWidth","height","innerHeight","onload","console","log","earth","drawScene","onerror","length","addEventListener","initScene","sun","animationId","scrollTimeout","rays","isAnimating","rotationAngle","earthRotationAngle","stars","baseOrbitSpeed","baseRotationSpeed","speedMultiplier","updateSpeedDisplay","daysPerFrame","toFixed","hoursPerFrame","timeScale","textContent","toLocaleString","innerHTML","cancelAnimationFrame","centerX","centerY","x","y","r","Math","min","earthOrbitRadius","eccentricity","semiMajorAxis","semiMinorAxis","sqrt","orbitRadius","axialTilt","orbitalInclination","cos","degToRad","sin","seasonalAngle","numRays","floor","i","angleDeg","angleRad","dir","start","baseOpacity","random","push","end","angle","phase","PI","color","generateRays","numStars","size","distance","baseBrightness","flickerSpeed","phase2","phase3","twinklePattern","hue","saturation","hasGlow","moveSpeed","moveAngle","moveRadius","movePhase","hasSecondaryMovement","secondaryMoveSpeed","secondaryMoveRadius","secondaryMovePhase","originalX","originalY","generateStars","updateEarthPosition","updateRayEndpoints","animate","deg","lineCircleIntersection","S","D","C","R","dx","dy","a","b","disc","sqrtDisc","t1","t2","tMin","getCanvasIntersection","W","H","tTop","abs","tBottom","tLeft","tRight","Infinity","ray","tFinal","tEarth","tCanvas","fillStyle","fillRect","time","performance","now","starMovementFactor","star","combinedFlicker","brightness","max","distanceFactor","moveX","moveY","currentX","currentY","glowSize","gradient","createRadialGradient","addColorStop","beginPath","arc","fill","drawStars","strokeStyle","moveTo","lineTo","closePath","stroke","lineWidth","save","clip","translate","rotate","rotationAngleRad","offsetX","drawImage","setTransform","restore","error","glowIntensity","glowGrad","drawEarth","sunGrad","pulseAmount","requestAnimationFrame","handleScroll","windowHeight","clearTimeout","querySelectorAll","forEach","section","getBoundingClientRect","top","classList","add","remove","toggleBtn","resetBtn","multiplierSlider","parseFloat","value","link","e","preventDefault","targetId","this","getAttribute","targetElement","querySelector","scrollIntoView","behavior","block"],"sourceRoot":""}